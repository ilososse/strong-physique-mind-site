// game.js
// - Tractions: INCHANGÉ
// - Pompes: détection basée sur l'ANGLE du coude (avant-bras / bras)
// - Handstand: timer (s) quand inversé + aligné, stop sur brisure
// - Handstand Push Up: reps, uniquement en handstand, fin sur brisure de pose (pas idle)
// - Planche: timer (s), fin sur brisure de ligne (alignement / retombée)
//   + à chaque set terminé: choix variante (Straddle / Full / Tuck / Autre + input)
//   + au moment du Save: nom d'exercice = "<Variante> planche" (ex: "Straddle planche")

import * as THREE from "three";
import { PoseLandmarker, FilesetResolver } from "https://esm.sh/@mediapipe/tasks-vision@0.10.14";
import { AudioManager } from "./audioManager.js";

// Supabase client (utilise la session déjà stockée côté site si même domaine)
const SUPABASE_URL = "https://lmblqxwssrxucbtowfkq.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_8cLzA_3Ud6AaLSi8mTf1Gw_4lJZTLjs";
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const isMobile =
  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// ----------------------------
// Utils
// ----------------------------
function clamp01(x) {
  return Math.max(0, Math.min(1, x));
}

function visOK(lm, min = 0.5) {
  return !!lm && (lm.visibility ?? 0) >= min;
}

// Angle au point B formé par A-B-C (en degrés)
function angleDeg(A, B, C) {
  if (!A || !B || !C) return null;

  const abx = A.x - B.x;
  const aby = A.y - B.y;
  const abz = (A.z ?? 0) - (B.z ?? 0);

  const cbx = C.x - B.x;
  const cby = C.y - B.y;
  const cbz = (C.z ?? 0) - (B.z ?? 0);

  const dot = abx * cbx + aby * cby + abz * cbz;
  const ab = Math.sqrt(abx * abx + aby * aby + abz * abz);
  const cb = Math.sqrt(cbx * cbx + cby * cby + cbz * cbz);
  if (ab === 0 || cb === 0) return null;

  const cos = Math.max(-1, Math.min(1, dot / (ab * cb)));
  return (Math.acos(cos) * 180) / Math.PI;
}

function uniq(arr) {
  return [...new Set((arr || []).filter((x) => typeof x === "string" && x.trim().length))];
}

function modeValue(arr) {
  // retourne la valeur la plus fréquente, ou null
  const counts = new Map();
  for (const v of arr || []) {
    if (!v || !v.trim()) continue;
    const k = v.trim();
    counts.set(k, (counts.get(k) || 0) + 1);
  }
  let best = null;
  let bestN = 0;
  for (const [k, n] of counts.entries()) {
    if (n > bestN) {
      bestN = n;
      best = k;
    }
  }
  return best;
}

// ----------------------------
// Exercise Registry (généralisable)
// ----------------------------
function createExerciseRegistry() {
  return {
    // ⚠️ Tractions inchangé
    Tractions: {
      name: "Tractions",
      mode: "reps",
      initState: "hanging",
      activeState: "pulling",
      idleEndState: "pulling",

      startHeadVsElbow: -0.02,
      completeHeadVsWrist: 0.04,

      requiredVisibility: 0.5,

      canStart(landmarks) {
        const nose = landmarks[0];
        const leftElbow = landmarks[13];
        const rightElbow = landmarks[14];

        if (
          !visOK(nose, this.requiredVisibility) ||
          !visOK(leftElbow, this.requiredVisibility) ||
          !visOK(rightElbow, this.requiredVisibility)
        ) {
          return false;
        }

        const headY = nose.y;
        const avgElbowY = (leftElbow.y + rightElbow.y) / 2;
        return headY > avgElbowY + this.startHeadVsElbow;
      },

      canComplete(landmarks) {
        const nose = landmarks[0];
        const leftWrist = landmarks[15];
        const rightWrist = landmarks[16];

        if (
          !visOK(nose, this.requiredVisibility) ||
          !visOK(leftWrist, this.requiredVisibility) ||
          !visOK(rightWrist, this.requiredVisibility)
        ) {
          return false;
        }

        const headY = nose.y;
        const avgWristY = (leftWrist.y + rightWrist.y) / 2;
        return headY <= avgWristY + this.completeHeadVsWrist;
      },

      getAscentSignal(landmarks) {
        const nose = landmarks[0];
        return visOK(nose, 0.5) ? nose.y : null;
      },
    },

    // ✅ Pompes: angle du coude (bras/avant-bras)
    Pompes: {
      name: "Pompes",
      mode: "reps",
      initState: "up",
      activeState: "down",
      idleEndState: "up",

      topAngleDeg: 148,
      bottomAngleDeg: 110,

      requiredVisibility: 0.4,
      armPolicy: "either",
      hysteresisDeg: 3,

      _elbowAngles(landmarks) {
        const ls = landmarks[11];
        const rs = landmarks[12];
        const le = landmarks[13];
        const re = landmarks[14];
        const lw = landmarks[15];
        const rw = landmarks[16];

        const leftOK =
          visOK(ls, this.requiredVisibility) &&
          visOK(le, this.requiredVisibility) &&
          visOK(lw, this.requiredVisibility);

        const rightOK =
          visOK(rs, this.requiredVisibility) &&
          visOK(re, this.requiredVisibility) &&
          visOK(rw, this.requiredVisibility);

        const aL = leftOK ? angleDeg(ls, le, lw) : null;
        const aR = rightOK ? angleDeg(rs, re, rw) : null;

        return { aL, aR };
      },

      _effectiveAngle(landmarks) {
        const { aL, aR } = this._elbowAngles(landmarks);

        if (this.armPolicy === "both") {
          if (aL == null || aR == null) return null;
          return (aL + aR) / 2;
        }

        if (aL == null && aR == null) return null;
        if (aL == null) return aR;
        if (aR == null) return aL;
        return (aL + aR) / 2;
      },

      canStart(landmarks) {
        const ang = this._effectiveAngle(landmarks);
        if (ang == null) return false;
        return ang <= this.bottomAngleDeg + this.hysteresisDeg;
      },

      canComplete(landmarks) {
        const ang = this._effectiveAngle(landmarks);
        if (ang == null) return false;
        return ang >= this.topAngleDeg - this.hysteresisDeg;
      },

      getAscentSignal(landmarks) {
        const ls = landmarks[11];
        const rs = landmarks[12];
        if (!visOK(ls, 0.35) || !visOK(rs, 0.35)) return null;
        return (ls.y + rs.y) / 2;
      },
    },

    // ✅ Handstand: timer en secondes (mode = "s")
    Handstand: {
      name: "Handstand",
      mode: "s",
      tracking: "timer",
      initState: "off",
      activeState: "on",
      idleEndState: "off",

      requiredVisibility: 0.4,

      invertMarginY: 0.06,

      straightStartDeg: 165,
      straightStopDeg: 150,
      hysteresisDeg: 2,

      sidePolicy: "either",

      _bodyAnglesAndInversion(landmarks) {
        const ls = landmarks[11];
        const rs = landmarks[12];
        const lh = landmarks[23];
        const rh = landmarks[24];
        const la = landmarks[27];
        const ra = landmarks[28];

        const leftOK =
          visOK(ls, this.requiredVisibility) &&
          visOK(lh, this.requiredVisibility) &&
          visOK(la, this.requiredVisibility);

        const rightOK =
          visOK(rs, this.requiredVisibility) &&
          visOK(rh, this.requiredVisibility) &&
          visOK(ra, this.requiredVisibility);

        const aL = leftOK ? angleDeg(ls, lh, la) : null;
        const aR = rightOK ? angleDeg(rs, rh, ra) : null;

        const invL = leftOK ? la.y + this.invertMarginY < ls.y : null;
        const invR = rightOK ? ra.y + this.invertMarginY < rs.y : null;

        return { aL, aR, invL, invR };
      },

      _effectiveStraightAngle(landmarks) {
        const { aL, aR } = this._bodyAnglesAndInversion(landmarks);

        if (this.sidePolicy === "both") {
          if (aL == null || aR == null) return null;
          return (aL + aR) / 2;
        }

        if (aL == null && aR == null) return null;
        if (aL == null) return aR;
        if (aR == null) return aL;
        return (aL + aR) / 2;
      },

      _isInverted(landmarks) {
        const { invL, invR } = this._bodyAnglesAndInversion(landmarks);

        if (this.sidePolicy === "both") {
          if (invL == null || invR == null) return false;
          return !!invL && !!invR;
        }

        if (invL == null && invR == null) return false;
        if (invL == null) return !!invR;
        if (invR == null) return !!invL;
        return !!invL || !!invR;
      },

      canStart(landmarks) {
        const inverted = this._isInverted(landmarks);
        if (!inverted) return false;

        const ang = this._effectiveStraightAngle(landmarks);
        if (ang == null) return false;

        return ang >= this.straightStartDeg - this.hysteresisDeg;
      },

      canComplete(landmarks) {
        const inverted = this._isInverted(landmarks);
        if (!inverted) return true;

        const ang = this._effectiveStraightAngle(landmarks);
        if (ang == null) return true;

        return ang <= this.straightStopDeg + this.hysteresisDeg;
      },

      getAscentSignal(landmarks) {
        const ls = landmarks[11];
        const rs = landmarks[12];
        if (!visOK(ls, 0.35) || !visOK(rs, 0.35)) return null;
        return (ls.y + rs.y) / 2;
      },
    },

    // ✅ Handstand Push Up: reps + fin sur brisure de pose
    "Handstand Push Up": {
      name: "Handstand Push Up",
      mode: "reps",
      initState: "up",
      activeState: "down",
      idleEndState: "up",

      endPolicy: "break_pose",
      breakPoseGraceMs: 350,

      requiredVisibility: 0.45,

      invertMarginY: 0.06,
      poseOkDeg: 150,

      topAngleDeg: 150,
      bottomAngleDeg: 105,
      hysteresisDeg: 3,

      armPolicy: "either",
      sidePolicy: "either",

      _bodyAnglesAndInversion(landmarks) {
        const ls = landmarks[11];
        const rs = landmarks[12];
        const lh = landmarks[23];
        const rh = landmarks[24];
        const la = landmarks[27];
        const ra = landmarks[28];

        const leftOK =
          visOK(ls, this.requiredVisibility) &&
          visOK(lh, this.requiredVisibility) &&
          visOK(la, this.requiredVisibility);

        const rightOK =
          visOK(rs, this.requiredVisibility) &&
          visOK(rh, this.requiredVisibility) &&
          visOK(ra, this.requiredVisibility);

        const aL = leftOK ? angleDeg(ls, lh, la) : null;
        const aR = rightOK ? angleDeg(rs, rh, ra) : null;

        const invL = leftOK ? la.y + this.invertMarginY < ls.y : null;
        const invR = rightOK ? ra.y + this.invertMarginY < rs.y : null;

        return { aL, aR, invL, invR };
      },

      _effectivePoseAngle(landmarks) {
        const { aL, aR } = this._bodyAnglesAndInversion(landmarks);

        if (this.sidePolicy === "both") {
          if (aL == null || aR == null) return null;
          return (aL + aR) / 2;
        }

        if (aL == null && aR == null) return null;
        if (aL == null) return aR;
        if (aR == null) return aL;
        return (aL + aR) / 2;
      },

      _isInverted(landmarks) {
        const { invL, invR } = this._bodyAnglesAndInversion(landmarks);

        if (this.sidePolicy === "both") {
          if (invL == null || invR == null) return false;
          return !!invL && !!invR;
        }

        if (invL == null && invR == null) return false;
        if (invL == null) return !!invR;
        if (invR == null) return !!invL;
        return !!invL || !!invR;
      },

      isPoseValid(landmarks) {
        const inverted = this._isInverted(landmarks);
        if (!inverted) return false;
        const ang = this._effectivePoseAngle(landmarks);
        if (ang == null) return false;
        return ang >= this.poseOkDeg;
      },

      _elbowAngles(landmarks) {
        const ls = landmarks[11];
        const rs = landmarks[12];
        const le = landmarks[13];
        const re = landmarks[14];
        const lw = landmarks[15];
        const rw = landmarks[16];

        const leftOK =
          visOK(ls, this.requiredVisibility) &&
          visOK(le, this.requiredVisibility) &&
          visOK(lw, this.requiredVisibility);

        const rightOK =
          visOK(rs, this.requiredVisibility) &&
          visOK(re, this.requiredVisibility) &&
          visOK(rw, this.requiredVisibility);

        const aL = leftOK ? angleDeg(ls, le, lw) : null;
        const aR = rightOK ? angleDeg(rs, re, rw) : null;

        return { aL, aR };
      },

      _effectiveElbowAngle(landmarks) {
        const { aL, aR } = this._elbowAngles(landmarks);

        if (this.armPolicy === "both") {
          if (aL == null || aR == null) return null;
          return (aL + aR) / 2;
        }

        if (aL == null && aR == null) return null;
        if (aL == null) return aR;
        if (aR == null) return aL;
        return (aL + aR) / 2;
      },

      canStart(landmarks) {
        if (!this.isPoseValid(landmarks)) return false;

        const ang = this._effectiveElbowAngle(landmarks);
        if (ang == null) return false;
        return ang <= this.bottomAngleDeg + this.hysteresisDeg;
      },

      canComplete(landmarks) {
        if (!this._isInverted(landmarks)) return false;

        const ang = this._effectiveElbowAngle(landmarks);
        if (ang == null) return false;
        return ang >= this.topAngleDeg - this.hysteresisDeg;
      },

      getAscentSignal(landmarks) {
        const ls = landmarks[11];
        const rs = landmarks[12];
        if (!visOK(ls, 0.35) || !visOK(rs, 0.35)) return null;
        return (ls.y + rs.y) / 2;
      },
    },

    // ✅ Planche: timer (s) + stop sur brisure d'alignement (pas idle)
    Planche: {
      name: "Planche",
      mode: "s",
      tracking: "timer",
      initState: "off",
      activeState: "on",
      idleEndState: "off",

      requiredVisibility: 0.45,

      // Critères:
      // 1) "ligne" torso/legs relativement droite: angle hip (shoulder-hip-ankle) proche de 180°
      // 2) "horizontalité" approximative: shoulders et hips quasi au même niveau en y-image
      // -> On stoppe si l'un des 2 casse de manière significative
      straightStartDeg: 160,
      straightStopDeg: 145,
      hysteresisDeg: 2,

      // shoulders ~ hips en y (planche = corps horizontal)
      // y (image) : plus petit = plus haut. Ici on veut juste "proche".
      shHipYStartMax: 0.07,
      shHipYStopMax: 0.11,

      // Bonus (pertinent) : épaules "devant" les poignets (planche lean)
      // (en x-image, selon orientation caméra c'est fragile => on le met permissif)
      requireShouldersAheadOfWrists: false,
      shAheadWristXMargin: 0.01,

      sidePolicy: "either", // either/both

      _poseMetrics(landmarks) {
        // L: shoulder 11, hip 23, ankle 27, wrist 15
        // R: shoulder 12, hip 24, ankle 28, wrist 16
        const ls = landmarks[11];
        const rs = landmarks[12];
        const lh = landmarks[23];
        const rh = landmarks[24];
        const la = landmarks[27];
        const ra = landmarks[28];
        const lw = landmarks[15];
        const rw = landmarks[16];

        const leftOK =
          visOK(ls, this.requiredVisibility) &&
          visOK(lh, this.requiredVisibility) &&
          visOK(la, this.requiredVisibility);

        const rightOK =
          visOK(rs, this.requiredVisibility) &&
          visOK(rh, this.requiredVisibility) &&
          visOK(ra, this.requiredVisibility);

        const aL = leftOK ? angleDeg(ls, lh, la) : null;
        const aR = rightOK ? angleDeg(rs, rh, ra) : null;

        const shHipYL = leftOK ? Math.abs(ls.y - lh.y) : null;
        const shHipYR = rightOK ? Math.abs(rs.y - rh.y) : null;

        const wristsOKL = visOK(lw, this.requiredVisibility) && visOK(ls, this.requiredVisibility);
        const wristsOKR = visOK(rw, this.requiredVisibility) && visOK(rs, this.requiredVisibility);

        // "épaules devant poignets" (optionnel / fragile mais parfois utile)
        // si mirroring, ça peut être inversé. Donc désactivé par défaut.
        const aheadL = wristsOKL ? (ls.x + this.shAheadWristXMargin < lw.x) : null;
        const aheadR = wristsOKR ? (rs.x + this.shAheadWristXMargin < rw.x) : null;

        return { aL, aR, shHipYL, shHipYR, aheadL, aheadR };
      },

      _effectiveAngle(landmarks) {
        const { aL, aR } = this._poseMetrics(landmarks);

        if (this.sidePolicy === "both") {
          if (aL == null || aR == null) return null;
          return (aL + aR) / 2;
        }

        if (aL == null && aR == null) return null;
        if (aL == null) return aR;
        if (aR == null) return aL;
        return (aL + aR) / 2;
      },

      _effectiveShHipY(landmarks) {
        const { shHipYL, shHipYR } = this._poseMetrics(landmarks);

        if (this.sidePolicy === "both") {
          if (shHipYL == null || shHipYR == null) return null;
          return (shHipYL + shHipYR) / 2;
        }

        if (shHipYL == null && shHipYR == null) return null;
        if (shHipYL == null) return shHipYR;
        if (shHipYR == null) return shHipYL;
        return (shHipYL + shHipYR) / 2;
      },

      _shouldersAheadWristsOK(landmarks) {
        if (!this.requireShouldersAheadOfWrists) return true;
        const { aheadL, aheadR } = this._poseMetrics(landmarks);

        if (this.sidePolicy === "both") {
          if (aheadL == null || aheadR == null) return false;
          return !!aheadL && !!aheadR;
        }

        if (aheadL == null && aheadR == null) return false;
        if (aheadL == null) return !!aheadR;
        if (aheadR == null) return !!aheadL;
        return !!aheadL || !!aheadR;
      },

      canStart(landmarks) {
        const ang = this._effectiveAngle(landmarks);
        const yDiff = this._effectiveShHipY(landmarks);
        if (ang == null || yDiff == null) return false;

        if (!this._shouldersAheadWristsOK(landmarks)) return false;

        return (
          ang >= this.straightStartDeg - this.hysteresisDeg &&
          yDiff <= this.shHipYStartMax
        );
      },

      canComplete(landmarks) {
        const ang = this._effectiveAngle(landmarks);
        const yDiff = this._effectiveShHipY(landmarks);

        // si tracking trop mauvais: stop
        if (ang == null || yDiff == null) return true;

        // si lean critère activé et perdu: stop
        if (!this._shouldersAheadWristsOK(landmarks)) return true;

        // rupture: angle ou horizontalité cassés
        if (ang <= this.straightStopDeg + this.hysteresisDeg) return true;
        if (yDiff >= this.shHipYStopMax) return true;

        return false;
      },

      getAscentSignal(landmarks) {
        const ls = landmarks[11];
        const rs = landmarks[12];
        if (!visOK(ls, 0.35) || !visOK(rs, 0.35)) return null;
        return (ls.y + rs.y) / 2;
      },
    },
  };
}

export class Game {
  constructor(renderDiv) {
    this.renderDiv = renderDiv;

    // Session context
    this.ctx = null;
    this.sessionStartedAt = null;

    // Registry
    this.EXERCISES = createExerciseRegistry();
    this.exercise = this.EXERCISES["Tractions"];

    // Three
    this.scene = null;
    this.camera = null;
    this.renderer = null;

    // DOM
    this.videoElement = null;
    this.startScreenOverlay = null;
    this.startButton = null;
    this.counterContainer = null;
    this.counterDisplay = null;
    this.gameOverContainer = null;
    this.gameOverText = null;
    this.loadingText = null;
    this.weightKgInput = null;
    this.saveSessionBtn = null;
    this.restartSetBtn = null;

    // Menu
    this.exerciseSelect = null;

    // ✅ PATCH: menu live + bouton back
    this.liveMenuContainer = null;
    this.backButton = null;
    this.isSwitchingExercise = false;
    this.autoFinalizeOnSwitch = true;

    // ✅ Timer state (Handstand/Planche)
    this.holdStartMs = null;
    this.lastTimerUiUpdateMs = 0;
    this.timerUiEveryMs = 100;

    // ✅ Break-pose state (HSPU)
    this.lastTrackedLandmarks = null;
    this.poseBrokenSinceMs = null;

    // ✅ Planche variants (1 variante par set)
    this.plancheSetVariants = []; // index aligned with this.sets
    this.plancheSetCustoms = [];  // si "Autre"
    this._plancheVariantUI = null;

    // MediaPipe
    this.poseLandmarker = null;
    this.lastVideoTime = -1;
    this.numPosesToTrack = 1;
    this.poses = [];
    this.lastLandmarkPositions = [];

    // State
    this.gameState = "loading";
    this.clock = new THREE.Clock();
    this.audioManager = new AudioManager();
    this.smoothingFactor = 0.4;

    // FSM reps
    this.repState = this.exercise.initState;
    this.repStarted = false;
    this.consecutiveFramesRequired = 2;
    this.stateFrameCount = 0;
    this.lastStateChange = Date.now();
    this.minTimeBetweenStateChanges = 100;

    // Sets
    this.sets = [];
    this.currentSetReps = 0;
    this.lastRepTimeMs = Date.now();
    this.setEndIdleMs = 2500;
    this.minRepsToAutoEnd = 1;

    // Anti-idle
    this.prevAscentSignal = null;
    this.isAscending = false;
    this.ascendEps = 0.0015;
    this.lastAscentTimeMs = Date.now();

    // Visuals
    this.poseLineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });
    this.circleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });

    this.poseConnections = [
      [11, 12],
      [11, 23],
      [12, 24],
      [23, 24],
      [11, 13],
      [13, 15],
      [12, 14],
      [14, 16],
      [23, 25],
      [25, 27],
      [24, 26],
      [26, 28],
    ];
    this.poseKeypointIndices = [0, 11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];

    this._init().catch((err) => {
      console.error("Initialization failed:", err);
      this._showError("Initialization failed. Check console.");
    });
  }

  setContext(ctx) {
    this.ctx = ctx || null;
    const ex = (this.ctx?.exercise || "Tractions").trim();
    if (this.EXERCISES[ex]) this._setExercise(ex);
    console.log("[game] ctx set:", this.ctx, "| exercise =", this.exercise?.name);
  }

  _setExercise(exName) {
    const cfg = this.EXERCISES[exName] || this.EXERCISES["Tractions"];
    this.exercise = cfg;

    if (!this.ctx) this.ctx = {};
    this.ctx.exercise = cfg.name;
    this.ctx.mode = cfg.mode;

    this.repState = cfg.initState;
    this.repStarted = false;
    this.stateFrameCount = 0;
    this.lastStateChange = Date.now();

    // reset timer state on exercise change
    this.holdStartMs = null;
    this.lastTimerUiUpdateMs = 0;

    // reset break-pose state
    this.lastTrackedLandmarks = null;
    this.poseBrokenSinceMs = null;

    // reset planche UI (but keep recorded variants for current session unless you switch exercise)
    this._removePlancheVariantUI();

    if (this.exerciseSelect) this.exerciseSelect.value = cfg.name;

    // sync live select
    const liveSelect = this.liveMenuContainer?.querySelector("select");
    if (liveSelect) liveSelect.value = cfg.name;

    console.log("[game] exercise configured:", cfg.name);
  }

  async _init() {
    this._setupDOMReferences();
    this._setupThree();
    await this._setupPoseTracking();
    await this.videoElement.play();

    window.addEventListener("resize", () => this._onResize());
    this.gameState = "ready";
    this._showStartButton();
    this._animate();
  }

  _setupDOMReferences() {
    this.videoElement = document.getElementById("videoElement");
    this.startScreenOverlay = document.getElementById("startScreenOverlay");
    this.startButton = document.getElementById("startButton");
    this.counterContainer = document.getElementById("counterContainer");
    this.counterDisplay = document.getElementById("counterDisplay");
    this.gameOverContainer = document.getElementById("gameOverContainer");
    this.gameOverText = document.getElementById("gameOverText");
    this.loadingText = document.getElementById("loadingText");
    this.weightKgInput = document.getElementById("weightKgInput");
    this.saveSessionBtn = document.getElementById("saveSessionBtn");
    this.restartSetBtn = document.getElementById("restartSetBtn");

    // menus + bouton back
    this._injectExerciseMenuOverlay();
    this._injectExerciseMenuLive(); // top-right (container), mais le menu lui-même sera top-center via style
    this._injectBackButtonLive();

    this.startButton.onclick = () => this._startGame();

    if (this.saveSessionBtn) {
      this.saveSessionBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        try {
          const payload = this._buildSessionPayload();
          await this._saveSessionToSupabase(payload);
          this.saveSessionBtn.style.display = "none";
          this._showStatusScreen("✅ Séance enregistrée !", "white", true);
        } catch (err) {
          console.error("[save] crash ❌", err);
          this._showStatusScreen("❌ Erreur sauvegarde (voir console)", "orange", true);
        }
      });
    }

    if (this.restartSetBtn) {
      this.restartSetBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.gameState === "paused") this._startNewSet();
      });
    }
  }

  // menu overlay (Start screen)
  _injectExerciseMenuOverlay() {
    if (!this.startScreenOverlay) return;

    const menu = document.createElement("div");
    menu.style.cssText = `
      position: relative;
      margin: 0 auto 12px auto;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      flex-wrap: wrap;
    `;

    const label = document.createElement("div");
    label.textContent = "Exercice :";
    label.style.cssText = "color: white; font-weight: 600; font-size: 14px;";

    const select = document.createElement("select");
    select.style.cssText = `
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.35);
      color: white;
      font-size: 14px;
      outline: none;
      cursor: pointer;
    `;

    Object.keys(this.EXERCISES).forEach((k) => {
      const opt = document.createElement("option");
      opt.value = k;
      opt.textContent = k;
      select.appendChild(opt);
    });

    select.value = this.exercise?.name || "Tractions";

    select.addEventListener("change", () => {
      this._setExercise(select.value);
      const liveSelect = this.liveMenuContainer?.querySelector("select");
      if (liveSelect) liveSelect.value = select.value;
    });

    menu.appendChild(label);
    menu.appendChild(select);

    if (this.startButton?.parentElement) {
      this.startButton.parentElement.insertBefore(menu, this.startButton);
    } else {
      this.startScreenOverlay.appendChild(menu);
    }

    this.exerciseSelect = select;
  }

  // menu live (pendant l'exercice) -> ✅ TOP-CENTER demandé
  _injectExerciseMenuLive() {
    if (!this.renderDiv) return;

    const wrap = document.createElement("div");
    wrap.style.cssText = `
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 999999;
      display: none; /* affiché à Start */
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    `;

    const row = document.createElement("div");
    row.style.cssText = `
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
    `;

    const label = document.createElement("div");
    label.textContent = "Exercice :";
    label.style.cssText = "color: white; font-weight: 600; font-size: 13px;";

    const select = document.createElement("select");
    select.style.cssText = `
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.35);
      color: white;
      font-size: 13px;
      outline: none;
      cursor: pointer;
    `;

    Object.keys(this.EXERCISES).forEach((k) => {
      const opt = document.createElement("option");
      opt.value = k;
      opt.textContent = k;
      select.appendChild(opt);
    });

    select.value = this.exercise?.name || "Tractions";
    select.addEventListener("change", () => this._handleExerciseSwitch(select.value));

    row.appendChild(label);
    row.appendChild(select);
    wrap.appendChild(row);

    const s = getComputedStyle(this.renderDiv);
    if (s.position === "static") this.renderDiv.style.position = "relative";

    this.renderDiv.appendChild(wrap);
    this.liveMenuContainer = wrap;
  }

  // bouton "page précédente" (pendant l'exercice) -> top-left
  _injectBackButtonLive() {
    if (!this.renderDiv) return;

    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = "↩ Quitter";
    btn.style.cssText = `
      position: absolute;
      top: 60px;
      left: 12px;
      z-index: 999999;
      display: none; /* affiché à Start */
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      color: white;
      font-weight: 700;
      font-size: 13px;
      cursor: pointer;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    `;

    btn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      const isTimer = this.exercise?.tracking === "timer" || this.exercise?.mode === "s";
      if (this.gameState === "tracking" && this.autoFinalizeOnSwitch) {
        if (this.currentSetReps >= 1) this._finalizeSet();
        else if (isTimer && this.holdStartMs != null) this._finalizeSet();
      }

      try {
        window.history.back();
      } catch {
        window.location.href = "/";
      }
    });

    const s = getComputedStyle(this.renderDiv);
    if (s.position === "static") this.renderDiv.style.position = "relative";

    this.renderDiv.appendChild(btn);
    this.backButton = btn;
  }

  async _handleExerciseSwitch(nextExerciseName) {
    if (this.isSwitchingExercise) return;
    if (!this.EXERCISES[nextExerciseName]) return;
    if (nextExerciseName === this.exercise?.name) return;

    this.isSwitchingExercise = true;

    try {
      if (this.exerciseSelect) this.exerciseSelect.value = nextExerciseName;

      if (this.gameState === "tracking") {
        if (this.autoFinalizeOnSwitch && this.currentSetReps >= 1) {
          this._finalizeSet();
        }
        this._setExercise(nextExerciseName);

        // si on change d'exercice, on reset les variantes planche du run en cours
        if (nextExerciseName !== "Planche") {
          // on garde les variants si tu reviens à planche pendant la session ? -> ici on garde.
        }

        this._startNewSet();
      } else if (this.gameState === "paused") {
        this._setExercise(nextExerciseName);
        this._startNewSet();
      } else {
        this._setExercise(nextExerciseName);
      }
    } finally {
      this.isSwitchingExercise = false;
    }
  }

  _setupThree() {
    const { clientWidth: width, clientHeight: height } = this.renderDiv;

    this.scene = new THREE.Scene();
    this.camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
    this.camera.position.z = 100;

    this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    this.renderer.setSize(width, height);
    this.renderer.setPixelRatio(window.devicePixelRatio);

    Object.assign(this.renderer.domElement.style, { position: "absolute", top: "0", left: "0", zIndex: "1" });
    this.renderDiv.appendChild(this.renderer.domElement);

    this.scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
    directionalLight.position.set(0, 0, 100);
    this.scene.add(directionalLight);

    for (let i = 0; i < this.numPosesToTrack; i++) {
      const lineGroup = new THREE.Group();
      lineGroup.visible = false;
      this.scene.add(lineGroup);

      this.poses.push({ landmarks: null, anchorPos: new THREE.Vector3(), lineGroup });
      this.lastLandmarkPositions.push([]);
    }
  }

  async _setupPoseTracking() {
    const vision = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
    );

    this.poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath:
          "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
        delegate: "GPU",
      },
      numPoses: this.numPosesToTrack,
      runningMode: "VIDEO",
      outputSegmentationMasks: false,
    });

    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false,
    });

    this.videoElement.srcObject = stream;

    return new Promise((resolve) => {
      this.videoElement.onloadedmetadata = () => resolve();
    });
  }

  _getVisibleVideoParameters() {
    if (!this.videoElement || this.videoElement.videoWidth === 0 || this.videoElement.videoHeight === 0) return null;

    const vNatW = this.videoElement.videoWidth;
    const vNatH = this.videoElement.videoHeight;
    const rW = this.renderDiv.clientWidth;
    const rH = this.renderDiv.clientHeight;
    if (!vNatW || !vNatH || !rW || !rH) return null;

    const videoAR = vNatW / vNatH;
    const renderDivAR = rW / rH;

    let offsetX, offsetY, visibleWidth, visibleHeight;

    if (videoAR > renderDivAR) {
      const scale = rH / vNatH;
      const scaledVideoWidth = vNatW * scale;
      const totalCroppedPixelsX = (scaledVideoWidth - rW) / scale;
      offsetX = totalCroppedPixelsX / 2;
      offsetY = 0;
      visibleWidth = vNatW - totalCroppedPixelsX;
      visibleHeight = vNatH;
    } else {
      const scale = rW / vNatW;
      const scaledVideoHeight = vNatH * scale;
      const totalCroppedPixelsY = (scaledVideoHeight - rH) / scale;
      offsetX = 0;
      offsetY = totalCroppedPixelsY / 2;
      visibleWidth = vNatW;
      visibleHeight = vNatH - totalCroppedPixelsY;
    }

    return { offsetX, offsetY, visibleWidth, visibleHeight, videoNaturalWidth: vNatW, videoNaturalHeight: vNatH };
  }

  _startGame() {
    if (this.gameState !== "ready") return;

    if (this.exerciseSelect?.value) this._setExercise(this.exerciseSelect.value);

    this.sessionStartedAt = new Date().toISOString();
    this.audioManager.resumeContext();
    if (this.startScreenOverlay) this.startScreenOverlay.style.display = "none";
    if (this.startButton) this.startButton.style.display = "none";
    if (this.counterContainer) this.counterContainer.style.display = "block";

    if (this.liveMenuContainer) this.liveMenuContainer.style.display = "block";
    if (this.backButton) this.backButton.style.display = "block";

    this.sets = [];
    this.plancheSetVariants = [];
    this.plancheSetCustoms = [];
    this._startNewSet();
  }

  _startNewSet() {
    if (this.gameOverContainer) this.gameOverContainer.style.display = "none";
    if (this.restartSetBtn) this.restartSetBtn.style.display = "none";
    if (this.saveSessionBtn) this.saveSessionBtn.style.display = "none";

    this._removePlancheVariantUI();

    this.gameState = "tracking";
    this.lastVideoTime = -1;
    this.clock.start();

    this.currentSetReps = 0;

    this.repState = this.exercise.initState;
    this.repStarted = false;
    this.stateFrameCount = 0;
    this.lastStateChange = Date.now();

    this.holdStartMs = null;
    this.lastTimerUiUpdateMs = 0;

    this.lastTrackedLandmarks = null;
    this.poseBrokenSinceMs = null;

    this.lastRepTimeMs = Date.now();
    this.prevAscentSignal = null;
    this.isAscending = false;
    this.lastAscentTimeMs = Date.now();

    this._updateCounterDisplay();
  }

  _finalizeSet() {
    if (this.currentSetReps >= this.minRepsToAutoEnd) this.sets.push(this.currentSetReps);

    this.gameState = "paused";

    const isTimer = this.exercise?.tracking === "timer" || this.exercise?.mode === "s";
    const unit = isTimer ? "s" : "reps";

    this._showStatusScreen(
      `Set terminé: ${this.currentSetReps} ${unit}\nTotal sets: ${this.sets.length} (${this.sets.join(" / ")})`,
      "white",
      true
    );

    // ✅ Si Planche: demander la variante pour CE set
    if (this.exercise?.name === "Planche" && this.currentSetReps >= 1) {
      const setIndex = this.sets.length - 1; // aligné car push déjà fait
      this._showPlancheVariantUI(setIndex);
    }

    if (this.restartSetBtn) this.restartSetBtn.style.display = "inline-block";
    if (this.saveSessionBtn) this.saveSessionBtn.style.display = "block";
  }

  _checkEndOfSet() {
    if (this.gameState !== "tracking") return;

    // ✅ fin de set sur brisure de pose (Handstand Push Up)
    if (this.exercise?.endPolicy === "break_pose") {
      const lm = this.lastTrackedLandmarks;
      if (!lm?.length) return;

      const ok = this.exercise.isPoseValid?.(lm);
      const now = Date.now();

      if (ok) {
        this.poseBrokenSinceMs = null;
        return;
      }

      if (this.poseBrokenSinceMs == null) this.poseBrokenSinceMs = now;

      const grace = this.exercise.breakPoseGraceMs ?? 300;
      if (now - this.poseBrokenSinceMs >= grace) {
        this._finalizeSet();
      }
      return;
    }

    // ✅ Handstand/Planche timer: finalize sur brisure dans _trackTimer (pas idle)
    if (this.exercise?.tracking === "timer" || this.exercise?.mode === "s") return;

    const now = Date.now();
    const idle = now - this.lastRepTimeMs;

    if (this.isAscending) return;
    const idleSinceAscent = now - this.lastAscentTimeMs;

    if (
      this.repState === this.exercise.idleEndState &&
      this.currentSetReps >= this.minRepsToAutoEnd &&
      idle >= this.setEndIdleMs &&
      idleSinceAscent >= this.setEndIdleMs
    ) {
      this._finalizeSet();
    }
  }

  _trackMovement(landmarks) {
    if (!landmarks?.length || !this.exercise) return;

    if (this.exercise?.tracking === "timer" || this.exercise?.mode === "s") {
      this._trackTimer(landmarks);
      return;
    }

    const ascentSignal = this.exercise.getAscentSignal?.(landmarks);
    if (ascentSignal != null) {
      if (this.prevAscentSignal !== null) {
        const delta = ascentSignal - this.prevAscentSignal;
        this.isAscending = delta < -this.ascendEps;
        if (this.isAscending) this.lastAscentTimeMs = Date.now();
      }
      this.prevAscentSignal = ascentSignal;
    }

    const now = Date.now();
    if (now - this.lastStateChange < this.minTimeBetweenStateChanges) return;

    let newState = this.repState;

    if (this.repState === this.exercise.initState) {
      if (!this.repStarted && this.exercise.canStart(landmarks, this)) {
        this.stateFrameCount++;
        if (this.stateFrameCount >= this.consecutiveFramesRequired) {
          newState = this.exercise.activeState;
          this.repStarted = true;
          this.audioManager.playStartBeep();
          this.stateFrameCount = 0;
          this.lastAscentTimeMs = Date.now();
        }
      } else {
        this.stateFrameCount = 0;
      }
    } else if (this.repState === this.exercise.activeState) {
      if (this.repStarted && this.exercise.canComplete(landmarks, this)) {
        this.stateFrameCount++;
        if (this.stateFrameCount >= this.consecutiveFramesRequired) {
          newState = this.exercise.initState;

          this.currentSetReps++;
          this.lastRepTimeMs = Date.now();
          this.lastAscentTimeMs = Date.now();

          this.audioManager.playCelebrationSound();
          this._updateCounterDisplay();

          this.stateFrameCount = 0;
          this.repStarted = false;
        }
      } else {
        this.stateFrameCount = 0;
      }
    }

    if (newState !== this.repState) {
      this.repState = newState;
      this.lastStateChange = now;
    }
  }

  // ✅ Timer tracking (Handstand + Planche)
  _trackTimer(landmarks) {
    const now = Date.now();
    if (now - this.lastStateChange < this.minTimeBetweenStateChanges) return;

    let newState = this.repState;

    if (this.repState === this.exercise.initState) {
      if (!this.repStarted && this.exercise.canStart(landmarks, this)) {
        this.stateFrameCount++;
        if (this.stateFrameCount >= this.consecutiveFramesRequired) {
          newState = this.exercise.activeState;
          this.repStarted = true;
          this.audioManager.playStartBeep();
          this.stateFrameCount = 0;
          this.lastStateChange = now;

          this.holdStartMs = now;
          this.currentSetReps = 0;
          this._updateCounterDisplay();
        }
      } else {
        this.stateFrameCount = 0;
      }
    } else if (this.repState === this.exercise.activeState) {
      if (this.holdStartMs != null) {
        const elapsedSec = Math.max(0, (now - this.holdStartMs) / 1000);
        const secInt = Math.floor(elapsedSec);
        if (secInt !== this.currentSetReps) {
          this.currentSetReps = secInt;
        }

        if (now - this.lastTimerUiUpdateMs >= this.timerUiEveryMs) {
          this.lastTimerUiUpdateMs = now;
          this._updateCounterDisplay();
        }
      }

      if (this.repStarted && this.exercise.canComplete(landmarks, this)) {
        this.stateFrameCount++;
        if (this.stateFrameCount >= this.consecutiveFramesRequired) {
          newState = this.exercise.initState;
          this.stateFrameCount = 0;
          this.repStarted = false;

          if (this.holdStartMs != null) {
            const elapsedSec = Math.max(0, (now - this.holdStartMs) / 1000);
            this.currentSetReps = Math.max(this.currentSetReps, Math.floor(elapsedSec));
          }
          this.holdStartMs = null;

          this.audioManager.playCelebrationSound();
          this._updateCounterDisplay();
          this._finalizeSet();
          return;
        }
      } else {
        this.stateFrameCount = 0;
      }
    }

    if (newState !== this.repState) {
      this.repState = newState;
      this.lastStateChange = now;
    }
  }

  _updateCounterDisplay() {
    const setsText = this.sets.length ? ` | Sets: ${this.sets.join(" / ")}` : "";
    const ex = this.exercise?.name || "Exercice";

    const isTimer = this.exercise?.tracking === "timer" || this.exercise?.mode === "s";
    if (isTimer) {
      this.counterDisplay.textContent = `${ex} — Time: ${this.currentSetReps}s${setsText}`;
      return;
    }

    this.counterDisplay.textContent = `${ex} — Reps: ${this.currentSetReps}${setsText}`;
  }

  _updatePose() {
    if (
      !this.poseLandmarker ||
      !this.videoElement.srcObject ||
      this.videoElement.readyState < 2 ||
      this.videoElement.videoWidth === 0
    )
      return;

    const videoTime = this.videoElement.currentTime;
    if (videoTime <= this.lastVideoTime) return;
    this.lastVideoTime = videoTime;

    const results = this.poseLandmarker.detectForVideo(this.videoElement, performance.now());
    if (!results?.landmarks?.length) {
      this.poses.forEach((p) => p.lineGroup && (p.lineGroup.visible = false));
      return;
    }

    const videoParams = this._getVisibleVideoParameters();
    if (!videoParams) return;

    const { clientWidth: canvasWidth, clientHeight: canvasHeight } = this.renderDiv;

    this.poses.forEach((pose, i) => {
      if (results.landmarks[i]?.length > 0) {
        const currentRawLandmarks = results.landmarks[i];

        if (!this.lastLandmarkPositions[i] || this.lastLandmarkPositions[i].length !== currentRawLandmarks.length) {
          this.lastLandmarkPositions[i] = currentRawLandmarks.map((lm) => ({ ...lm }));
        }

        const smoothedLandmarks = currentRawLandmarks.map((lm, lmIndex) => {
          const prevLm = this.lastLandmarkPositions[i][lmIndex];
          return {
            x: this.smoothingFactor * lm.x + (1 - this.smoothingFactor) * prevLm.x,
            y: this.smoothingFactor * lm.y + (1 - this.smoothingFactor) * prevLm.y,
            z: this.smoothingFactor * lm.z + (1 - this.smoothingFactor) * prevLm.z,
            visibility: lm.visibility,
          };
        });

        this.lastLandmarkPositions[i] = smoothedLandmarks.map((lm) => ({ ...lm }));
        pose.landmarks = smoothedLandmarks;

        this.lastTrackedLandmarks = smoothedLandmarks;

        if (this.gameState === "tracking") this._trackMovement(smoothedLandmarks);

        this._updatePoseVisuals(i, smoothedLandmarks, videoParams, canvasWidth, canvasHeight);
        pose.lineGroup.visible = true;
      } else {
        pose.landmarks = null;
        if (pose.lineGroup) pose.lineGroup.visible = false;
      }
    });
  }

  _updatePoseVisuals(poseIndex, landmarks, videoParams, canvasWidth, canvasHeight) {
    const pose = this.poses[poseIndex];
    const lineGroup = pose.lineGroup;

    while (lineGroup.children.length) {
      const child = lineGroup.children[0];
      lineGroup.remove(child);
      if (child.geometry) child.geometry.dispose();
      if (child.material && child.material !== this.poseLineMaterial && child.material !== this.circleMaterial) {
        child.material.dispose?.();
      }
    }

    const points3D = landmarks.map((lm) => {
      const lmOriginalX = lm.x * videoParams.videoNaturalWidth;
      const lmOriginalY = lm.y * videoParams.videoNaturalHeight;

      const normX = clamp01((lmOriginalX - videoParams.offsetX) / videoParams.visibleWidth);
      const normY = clamp01((lmOriginalY - videoParams.offsetY) / videoParams.visibleHeight);

      const x = (1 - normX) * canvasWidth - canvasWidth / 2;
      const y = (1 - normY) * canvasHeight - canvasHeight / 2;

      const isVisible = (lm.visibility ?? 0) > 0.3;
      return new THREE.Vector3(x, y, isVisible ? 1.1 : -10000);
    });

    const lineZ = 1.0;
    const circleRadius = isMobile ? 6 : 8;

    this.poseConnections.forEach(([a, b]) => {
      const p1 = points3D[a];
      const p2 = points3D[b];
      if (p1?.z > -1000 && p2?.z > -1000) {
        const geometry = new THREE.BufferGeometry().setFromPoints([p1.clone().setZ(lineZ), p2.clone().setZ(lineZ)]);
        lineGroup.add(new THREE.Line(geometry, this.poseLineMaterial));
      }
    });

    this.poseKeypointIndices.forEach((idx) => {
      const pos = points3D[idx];
      if (!pos || pos.z <= -1000) return;

      let color = 0x0000ff;
      if (idx === 0) color = 0xff0000;
      else if (idx === 13 || idx === 14) color = 0xffff00;
      else if (idx === 15 || idx === 16) color = 0x00ff00;

      const material = color === 0x0000ff ? this.circleMaterial : new THREE.MeshBasicMaterial({ color });
      const circle = new THREE.Mesh(new THREE.CircleGeometry(circleRadius, 16), material);
      circle.position.copy(pos);
      circle.position.z = lineZ + 0.1;
      lineGroup.add(circle);
    });

    lineGroup.visible = true;
  }

  _showStartButton() {
    if (this.loadingText) this.loadingText.style.display = "none";
    if (this.startButton) this.startButton.style.display = "block";
  }

  _showStatusScreen(message, color = "white") {
    if (!this.gameOverContainer || !this.gameOverText) return;
    this.gameOverContainer.style.display = "block";
    this.gameOverText.innerText = message;
    this.gameOverText.style.color = color;
  }

  _showError(message) {
    this.gameState = "error";
    this._showStatusScreen(`ERROR: ${message}`, "orange");
  }

  _onResize() {
    const { clientWidth: width, clientHeight: height } = this.renderDiv;
    this.camera.left = width / -2;
    this.camera.right = width / 2;
    this.camera.top = height / 2;
    this.camera.bottom = height / -2;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height);
  }

  _animate() {
    requestAnimationFrame(() => this._animate());
    if (this.gameState === "tracking") {
      this._updatePose();
      this._checkEndOfSet();
    }
    this.renderer.render(this.scene, this.camera);
  }

  // ----------------------------
  // ✅ Planche variant UI
  // ----------------------------
  _removePlancheVariantUI() {
    if (this._plancheVariantUI?.parentElement) {
      this._plancheVariantUI.parentElement.removeChild(this._plancheVariantUI);
    }
    this._plancheVariantUI = null;
  }

  _showPlancheVariantUI(setIndex) {
    if (!this.gameOverContainer) return;

    this._removePlancheVariantUI();

    const wrap = document.createElement("div");
    wrap.style.cssText = `
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      color: white;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-start;
      max-width: 360px;
    `;

    const title = document.createElement("div");
    title.textContent = "Variante de Planche (pour ce set) :";
    title.style.cssText = "font-weight: 700; font-size: 13px;";

    const row = document.createElement("div");
    row.style.cssText = "display:flex; gap:8px; align-items:center; width:100%; flex-wrap:wrap;";

    const select = document.createElement("select");
    select.style.cssText = `
      padding: 7px 9px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.35);
      color: white;
      font-size: 13px;
      outline: none;
      cursor: pointer;
    `;

    const options = ["Straddle", "Full", "Tuck", "Autre"];
    options.forEach((v) => {
      const opt = document.createElement("option");
      opt.value = v;
      opt.textContent = v;
      select.appendChild(opt);
    });

    // default: Tuck (comme demandé "par défaut")
    select.value = this.plancheSetVariants[setIndex] || "Tuck";

    const input = document.createElement("input");
    input.type = "text";
    input.placeholder = "Autre (ex: Advanced tuck)";
    input.style.cssText = `
      padding: 7px 9px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.25);
      color: white;
      font-size: 13px;
      outline: none;
      display: none;
      min-width: 180px;
    `;

    input.value = this.plancheSetCustoms[setIndex] || "";

    const apply = () => {
      const v = select.value;
      this.plancheSetVariants[setIndex] = v;

      if (v === "Autre") {
        input.style.display = "inline-block";
        this.plancheSetCustoms[setIndex] = (input.value || "").trim();
      } else {
        input.style.display = "none";
        this.plancheSetCustoms[setIndex] = "";
      }
    };

    select.addEventListener("change", apply);
    input.addEventListener("input", apply);
    apply();

    row.appendChild(select);
    row.appendChild(input);

    const hint = document.createElement("div");
    hint.textContent = "Le nom sauvegardé sera par ex: “Straddle planche”.";
    hint.style.cssText = "font-size: 12px; opacity: 0.9;";

    wrap.appendChild(title);
    wrap.appendChild(row);
    wrap.appendChild(hint);

    this.gameOverContainer.appendChild(wrap);
    this._plancheVariantUI = wrap;
  }

  _getFinalPlancheExerciseName() {
    // On choisit la variante la plus fréquente sur la session.
    // Si mix: on prend la "mode" (la plus fréquente). Si égalité: la dernière.
    const variants = (this.plancheSetVariants || []).map((v, i) => {
      if (!v) return "";
      if (v === "Autre") {
        const custom = (this.plancheSetCustoms?.[i] || "").trim();
        return custom ? custom : "Autre";
      }
      return v;
    });

    const unique = uniq(variants);
    if (!unique.length) return "Tuck planche"; // défaut safe

    const most = modeValue(variants);
    let chosen = most || variants[variants.length - 1] || unique[0];

    chosen = chosen.trim();
    if (!chosen) chosen = "Tuck";

    return `${chosen} planche`;
  }

  // ----------------------------
  // Payload / Save
  // ----------------------------
  _buildSessionPayload() {
    const sets = [...this.sets];

    const baseExName = this.exercise?.name || this.ctx?.exercise || "Tractions";
    const exMode = this.exercise?.mode || this.ctx?.mode || "reps";

    // ✅ Planche: renommer selon variante au moment du Save
    let exName = baseExName;
    if (baseExName === "Planche") {
      exName = this._getFinalPlancheExerciseName();
    }

    return {
      date: this.ctx?.sessionDate || new Date().toISOString().slice(0, 10),
      duration: "",
      exercises: [
        {
          name: exName,
          mode: exMode,
          weight: String(Number(this.weightKgInput?.value || 0)),
          s1: sets[0]?.toString() || "",
          s2: sets[1]?.toString() || "",
          s3: sets[2]?.toString() || "",
          s4: sets[3]?.toString() || "",
          s5: sets[4]?.toString() || "",
          s6: sets[5]?.toString() || "",
          s7: sets[6]?.toString() || "",
          s8: sets[7]?.toString() || "",
          ressenti: "",
        },
      ],
    };
  }

  async _ensureUsername() {
    if (this.ctx?.username) return;

    const { data, error } = await supabase
      .from("user_profiles")
      .select("username")
      .eq("user_id", this.ctx.userId)
      .single();

    if (error) {
      console.warn("[game] cannot fetch username", error);
      return;
    }
    this.ctx.username = data?.username || "alif";
  }

  async _saveSessionToSupabase(finalPayload) {
    if (!this.ctx?.userId) {
      console.warn("[save] No ctx.userId, skip saving");
      return;
    }

    await this._ensureUsername();

    const row = {
      user_id: this.ctx.userId,
      username: this.ctx.username,
      session_date: finalPayload.date || new Date().toISOString().slice(0, 10),
      payload: finalPayload,
    };

    const { data, error } = await supabase.from("workout_sessions").insert([row]).select();
    if (error) {
      console.error("[save] Supabase insert error ❌", error);
      throw error;
    }

    console.log("[save] inserted ✅", data);
  }
}
